//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Transaction_Record_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Get all transaction records
     * @param bommelId (optional) Fetch all transaction records which are connected to the bommel
     * @param detached (optional) Fetch all transaction records which are not connected to any bommel
     * @param page (optional) Current page you want to display, starts with 0
     * @param size (optional) 
     * @return List of transaction records, empty list if none are available
     */
    all(bommelId: number | undefined, detached: boolean | undefined, page: number | undefined, size: number | undefined): Promise<TransactionRecord[]> {
        let url_ = this.baseUrl + "/all?";
        if (bommelId === null)
            throw new Error("The parameter 'bommelId' cannot be null.");
        else if (bommelId !== undefined)
            url_ += "bommelId=" + encodeURIComponent("" + bommelId) + "&";
        if (detached === null)
            throw new Error("The parameter 'detached' cannot be null.");
        else if (detached !== undefined)
            url_ += "detached=" + encodeURIComponent("" + detached) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: Response): Promise<TransactionRecord[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionRecord.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionRecord[]>(null as any);
    }

    /**
     * Add a transaction record to a bommel
     * @param bommelId (optional) 
     * @return Specified transaction record was attached to bommel
     */
    bommelPATCH(id: number, bommelId: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{id}/bommel?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (bommelId === null)
            throw new Error("The parameter 'bommelId' cannot be null.");
        else if (bommelId !== undefined)
            url_ += "bommelId=" + encodeURIComponent("" + bommelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPATCH(_response);
        });
    }

    protected processBommelPATCH(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Specified transaction record id was not found", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bommel was not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Bommel_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Create bommel
     * @return Bommel successfully created
     */
    bommelPOST(body: Bommel): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPOST(_response);
        });
    }

    protected processBommelPOST(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Bommel.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bommel has no parent, cannot create root-bommel", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Move a bommel underneath a different parent
     * @return Bommel successfully moved
     */
    to(id: number, newParentId: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/move/{id}/to/{newParentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (newParentId === undefined || newParentId === null)
            throw new Error("The parameter 'newParentId' must be defined.");
        url_ = url_.replace("{newParentId}", encodeURIComponent("" + newParentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTo(_response);
        });
    }

    protected processTo(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized to move bommel", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("<li>Bommel not found <li>New parent bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Fetch root-bommel for organization
     * @return Root-Bommel found
     */
    root(orgId: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/root/{orgId}";
        if (orgId === undefined || orgId === null)
            throw new Error("The parameter 'orgId' must be defined.");
        url_ = url_.replace("{orgId}", encodeURIComponent("" + orgId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoot(_response);
        });
    }

    protected processRoot(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Update bommel
     * @return Bommel successfully updated
     */
    bommelPUT(id: number, body: Bommel): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPUT(_response);
        });
    }

    protected processBommelPUT(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Fetch a bommel by its id
     * @return Bommel found
     */
    bommelGET(id: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelGET(_response);
        });
    }

    protected processBommelGET(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Delete bommel
     * @param recursive (optional) 
     * @return Bommel successfully deleted
     */
    bommelDELETE(id: number, recursive: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/bommel/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (recursive === null)
            throw new Error("The parameter 'recursive' cannot be null.");
        else if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelDELETE(_response);
        });
    }

    protected processBommelDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Fetch the children of bommel
     * @return Children of bommel
     */
    children(id: number): Promise<Bommel[]> {
        let url_ = this.baseUrl + "/bommel/{id}/children";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChildren(_response);
        });
    }

    protected processChildren(response: Response): Promise<Bommel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Bommel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel[]>(null as any);
    }

    /**
     * Fetch the children of bommel recursively
     * @return Recursive children of bommel
     */
    recursive(id: number): Promise<TreeSearchBommel[]> {
        let url_ = this.baseUrl + "/bommel/{id}/children/recursive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecursive(_response);
        });
    }

    protected processRecursive(response: Response): Promise<TreeSearchBommel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeSearchBommel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreeSearchBommel[]>(null as any);
    }
}

export class Document_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Upload Document
     * @param file (optional) 
     * @param bommelId (optional) 
     * @param privatelyPaid (optional) 
     * @param type (optional) 
     * @return OK
     */
    documentPOST(file: FileParameter | undefined, bommelId: number | null | undefined, privatelyPaid: boolean | undefined, type: DocumentType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (bommelId !== null && bommelId !== undefined)
            content_.append("bommelId", bommelId.toString());
        if (privatelyPaid === null || privatelyPaid === undefined)
            throw new Error("The parameter 'privatelyPaid' cannot be null.");
        else
            content_.append("privatelyPaid", privatelyPaid.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("type", type.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentPOST(_response);
        });
    }

    protected processDocumentPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Document By Key
     * @return OK
     */
    documentGET(documentKey: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/document/{documentKey}";
        if (documentKey === undefined || documentKey === null)
            throw new Error("The parameter 'documentKey' must be defined.");
        url_ = url_.replace("{documentKey}", encodeURIComponent("" + documentKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentGET(_response);
        });
    }

    protected processDocumentGET(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class Process_Instance_Management_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Get Processes
     * @return OK
     */
    processes(): Promise<void> {
        let url_ = this.baseUrl + "/management/processes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcesses(_response);
        });
    }

    protected processProcesses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Process Info
     * @return OK
     */
    processes2(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcesses2(_response);
        });
    }

    protected processProcesses2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Cancel Process Instance Id
     * @return OK
     */
    instancesDELETE(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesDELETE(_response);
        });
    }

    protected processInstancesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Instance In Error
     * @return OK
     */
    error(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/error";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processError(_response);
        });
    }

    protected processError(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Migrate Instance
     * @return OK
     */
    migrate(processId: string, processInstanceId: string, body: ProcessMigrationSpec): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/migrate";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMigrate(_response);
        });
    }

    protected processMigrate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Work Items In Process Instance
     * @return OK
     */
    nodeInstancesGET(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodeInstances";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodeInstancesGET(_response);
        });
    }

    protected processNodeInstancesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retrigger Node Instance Id
     * @return OK
     */
    nodeInstancesPOST(nodeInstanceId: string, processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodeInstances/{nodeInstanceId}";
        if (nodeInstanceId === undefined || nodeInstanceId === null)
            throw new Error("The parameter 'nodeInstanceId' must be defined.");
        url_ = url_.replace("{nodeInstanceId}", encodeURIComponent("" + nodeInstanceId));
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodeInstancesPOST(_response);
        });
    }

    protected processNodeInstancesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Cancel Node Instance Id
     * @return OK
     */
    nodeInstancesDELETE(nodeInstanceId: string, processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodeInstances/{nodeInstanceId}";
        if (nodeInstanceId === undefined || nodeInstanceId === null)
            throw new Error("The parameter 'nodeInstanceId' must be defined.");
        url_ = url_.replace("{nodeInstanceId}", encodeURIComponent("" + nodeInstanceId));
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodeInstancesDELETE(_response);
        });
    }

    protected processNodeInstancesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Trigger Node Instance Id
     * @return OK
     */
    nodesPOST(nodeId: string, processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodes/{nodeId}";
        if (nodeId === undefined || nodeId === null)
            throw new Error("The parameter 'nodeId' must be defined.");
        url_ = url_.replace("{nodeId}", encodeURIComponent("" + nodeId));
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodesPOST(_response);
        });
    }

    protected processNodesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retrigger Instance In Error
     * @return OK
     */
    retrigger(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/retrigger";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrigger(_response);
        });
    }

    protected processRetrigger(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Skip Instance In Error
     * @return OK
     */
    skip(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/skip";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSkip(_response);
        });
    }

    protected processSkip(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Migrate All Instances
     * @return OK
     */
    migrate2(processId: string, body: ProcessMigrationSpec): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/migrate";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMigrate2(_response);
        });
    }

    protected processMigrate2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Process Nodes
     * @return OK
     */
    nodesGET(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/nodes";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodesGET(_response);
        });
    }

    protected processNodesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Source_Files_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Get Source File By Uri
     * @param uri (optional) 
     * @return OK
     */
    sources(uri: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/sources?";
        if (uri === null)
            throw new Error("The parameter 'uri' cannot be null.");
        else if (uri !== undefined)
            url_ += "uri=" + encodeURIComponent("" + uri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSources(_response);
        });
    }

    protected processSources(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Source File By Process Id
     * @return OK
     */
    source(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/source";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSource(_response);
        });
    }

    protected processSource(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Source Files By Process Id
     * @return OK
     */
    sourcesAll(processId: string): Promise<SourceFile[]> {
        let url_ = this.baseUrl + "/management/processes/{processId}/sources";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSourcesAll(_response);
        });
    }

    protected processSourcesAll(response: Response): Promise<SourceFile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SourceFile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SourceFile[]>(null as any);
    }
}

export class Member_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Validates the member input
     * @return Validation successful
     */
    validate(body: Member): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/member/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation failed", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }
}

export class Quarkus_Topics_Information_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Get Topics
     * @return OK
     */
    topics(): Promise<void> {
        let url_ = this.baseUrl + "/messaging/topics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTopics(_response);
        });
    }

    protected processTopics(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Organization_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Create a new organization
     * @return Creation started successfully
     */
    organizationPOST(body: NewOrganizationInput): Promise<CreateOrganizationResponse> {
        let url_ = this.baseUrl + "/organization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationPOST(_response);
        });
    }

    protected processOrganizationPOST(response: Response): Promise<CreateOrganizationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = CreateOrganizationResponse.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation of fields failed", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = CreateOrganizationResponse.fromJS(resultData500);
            return throwException("Process failed", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateOrganizationResponse>(null as any);
    }

    /**
     * Get my organization
     * @return Own organization retrieved successfully
     */
    my(): Promise<Organization1> {
        let url_ = this.baseUrl + "/organization/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMy(_response);
        });
    }

    protected processMy(response: Response): Promise<Organization1> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization1.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for user", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization1>(null as any);
    }

    /**
     * Validates the organization input
     * @return Validation successful
     */
    validate2(body: Organization1): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/organization/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate2(_response);
        });
    }

    protected processValidate2(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation failed", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }

    /**
     * Get organization
     * @return Organization retrieved successfully
     */
    organizationGET(slug: string): Promise<Organization1> {
        let url_ = this.baseUrl + "/organization/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationGET(_response);
        });
    }

    protected processOrganizationGET(response: Response): Promise<Organization1> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization1.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for provided slug", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization1>(null as any);
    }

    /**
     * Get organization members
     * @return Members retrieved successfully
     */
    members(slug: string): Promise<Member[]> {
        let url_ = this.baseUrl + "/organization/{slug}/members";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers(_response);
        });
    }

    protected processMembers(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for provided slug", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(null as any);
    }
}

export class Process_Svg_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Get Process Svg
     * @return OK
     */
    processes3(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/svg/processes/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcesses3(_response);
        });
    }

    protected processProcesses3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Execution Path By Process Instance Id
     * @return OK
     */
    instancesGET(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/svg/processes/{processId}/instances/{processInstanceId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesGET(_response);
        });
    }

    protected processInstancesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Bommel implements IBommel {
    id?: number;
    name?: string;
    emoji?: string;
    responsibleMember?: Member;
    organization?: Organization1;
    parent?: Bommel;
    children?: Bommel[];

    [key: string]: any;

    constructor(data?: IBommel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.emoji = _data["emoji"];
            this.responsibleMember = _data["responsibleMember"] ? Member.fromJS(_data["responsibleMember"]) : <any>undefined;
            this.organization = _data["organization"] ? Organization1.fromJS(_data["organization"]) : <any>undefined;
            this.parent = _data["parent"] ? Bommel.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Bommel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Bommel {
        data = typeof data === 'object' ? data : {};
        let result = new Bommel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["emoji"] = this.emoji;
        data["responsibleMember"] = this.responsibleMember ? this.responsibleMember.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): Bommel {
        const json = this.toJSON();
        let result = new Bommel();
        result.init(json);
        return result;
    }
}

export interface IBommel {
    id?: number;
    name?: string;
    emoji?: string;
    responsibleMember?: Member;
    organization?: Organization1;
    parent?: Bommel;
    children?: Bommel[];

    [key: string]: any;
}

export class CreateOrganizationResponse implements ICreateOrganizationResponse {
    id?: string;
    error?: string;

    [key: string]: any;

    constructor(data?: ICreateOrganizationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): CreateOrganizationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["error"] = this.error;
        return data;
    }

    clone(): CreateOrganizationResponse {
        const json = this.toJSON();
        let result = new CreateOrganizationResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationResponse {
    id?: string;
    error?: string;

    [key: string]: any;
}

export enum DocumentType {
    RECEIPT = "RECEIPT",
    INVOICE = "INVOICE",
}

export class InvoiceData implements IInvoiceData {
    referenceKey?: number;
    total?: number;
    invoiceDate?: Date;
    currencyCode?: string;
    customerName?: string | undefined;
    purchaseOrderNumber?: string | undefined;
    invoiceId?: string | undefined;
    dueDate?: DueDate;
    amountDue?: number | undefined;
    sender?: Sender;
    receiver?: Receiver;

    [key: string]: any;

    constructor(data?: IInvoiceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.referenceKey = _data["referenceKey"];
            this.total = _data["total"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.currencyCode = _data["currencyCode"];
            this.customerName = _data["customerName"];
            this.purchaseOrderNumber = _data["purchaseOrderNumber"];
            this.invoiceId = _data["invoiceId"];
            this.dueDate = _data["dueDate"];
            this.amountDue = _data["amountDue"];
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
        }
    }

    static fromJS(data: any): InvoiceData {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["referenceKey"] = this.referenceKey;
        data["total"] = this.total;
        data["invoiceDate"] = this.invoiceDate ? formatDate(this.invoiceDate) : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["customerName"] = this.customerName;
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["invoiceId"] = this.invoiceId;
        data["dueDate"] = this.dueDate;
        data["amountDue"] = this.amountDue;
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        return data;
    }

    clone(): InvoiceData {
        const json = this.toJSON();
        let result = new InvoiceData();
        result.init(json);
        return result;
    }
}

export interface IInvoiceData {
    referenceKey?: number;
    total?: number;
    invoiceDate?: Date;
    currencyCode?: string;
    customerName?: string | undefined;
    purchaseOrderNumber?: string | undefined;
    invoiceId?: string | undefined;
    dueDate?: DueDate;
    amountDue?: number | undefined;
    sender?: Sender;
    receiver?: Receiver;

    [key: string]: any;
}

export class InvoiceModelInput implements IInvoiceModelInput {
    invoiceData?: InvoiceData;

    [key: string]: any;

    constructor(data?: IInvoiceModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.invoiceData = _data["invoiceData"] ? InvoiceData.fromJS(_data["invoiceData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoiceModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["invoiceData"] = this.invoiceData ? this.invoiceData.toJSON() : <any>undefined;
        return data;
    }

    clone(): InvoiceModelInput {
        const json = this.toJSON();
        let result = new InvoiceModelInput();
        result.init(json);
        return result;
    }
}

export interface IInvoiceModelInput {
    invoiceData?: InvoiceData;

    [key: string]: any;
}

export class InvoiceModelOutput implements IInvoiceModelOutput {
    id?: string;
    invoiceData?: InvoiceData;

    [key: string]: any;

    constructor(data?: IInvoiceModelOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.invoiceData = _data["invoiceData"] ? InvoiceData.fromJS(_data["invoiceData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoiceModelOutput {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceModelOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["invoiceData"] = this.invoiceData ? this.invoiceData.toJSON() : <any>undefined;
        return data;
    }

    clone(): InvoiceModelOutput {
        const json = this.toJSON();
        let result = new InvoiceModelOutput();
        result.init(json);
        return result;
    }
}

export interface IInvoiceModelOutput {
    id?: string;
    invoiceData?: InvoiceData;

    [key: string]: any;
}

/** An example of a Hopps Member */
export class Member implements IMember {
    id?: number;
    /** First Name of the Member */
    firstName!: string;
    /** Last Name of the Member */
    lastName!: string;
    email!: string;
    organizations?: Organization1[];

    [key: string]: any;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(Organization1.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): Member {
        const json = this.toJSON();
        let result = new Member();
        result.init(json);
        return result;
    }
}

/** An example of a Hopps Member */
export interface IMember {
    id?: number;
    /** First Name of the Member */
    firstName: string;
    /** Last Name of the Member */
    lastName: string;
    email: string;
    organizations?: Organization1[];

    [key: string]: any;
}

export class NewOrganizationInput implements INewOrganizationInput {
    owner!: OwnerInput;
    newPassword!: string;
    organization!: OrganizationInput;

    [key: string]: any;

    constructor(data?: INewOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.owner = new OwnerInput();
            this.organization = new OrganizationInput();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.owner = _data["owner"] ? OwnerInput.fromJS(_data["owner"]) : new OwnerInput();
            this.newPassword = _data["newPassword"];
            this.organization = _data["organization"] ? OrganizationInput.fromJS(_data["organization"]) : new OrganizationInput();
        }
    }

    static fromJS(data: any): NewOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["newPassword"] = this.newPassword;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data;
    }

    clone(): NewOrganizationInput {
        const json = this.toJSON();
        let result = new NewOrganizationInput();
        result.init(json);
        return result;
    }
}

export interface INewOrganizationInput {
    owner: OwnerInput;
    newPassword: string;
    organization: OrganizationInput;

    [key: string]: any;
}

export class NewOrganizationModelInput implements INewOrganizationModelInput {
    owner?: Member;
    organization?: Organization1;
    newPassword?: string;

    [key: string]: any;

    constructor(data?: INewOrganizationModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.owner = _data["owner"] ? Member.fromJS(_data["owner"]) : <any>undefined;
            this.organization = _data["organization"] ? Organization1.fromJS(_data["organization"]) : <any>undefined;
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): NewOrganizationModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): NewOrganizationModelInput {
        const json = this.toJSON();
        let result = new NewOrganizationModelInput();
        result.init(json);
        return result;
    }
}

export interface INewOrganizationModelInput {
    owner?: Member;
    organization?: Organization1;
    newPassword?: string;

    [key: string]: any;
}

export class NewOrganizationModelOutput implements INewOrganizationModelOutput {
    id?: string;

    [key: string]: any;

    constructor(data?: INewOrganizationModelOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NewOrganizationModelOutput {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationModelOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }

    clone(): NewOrganizationModelOutput {
        const json = this.toJSON();
        let result = new NewOrganizationModelOutput();
        result.init(json);
        return result;
    }
}

export interface INewOrganizationModelOutput {
    id?: string;

    [key: string]: any;
}

/** An example of a valid address */
export class Organization implements IOrganization {
    street?: string;
    number?: string;
    city?: string;
    plz?: string;
    additionalLine?: string;

    [key: string]: any;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.street = _data["street"];
            this.number = _data["number"];
            this.city = _data["city"];
            this.plz = _data["plz"];
            this.additionalLine = _data["additionalLine"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["street"] = this.street;
        data["number"] = this.number;
        data["city"] = this.city;
        data["plz"] = this.plz;
        data["additionalLine"] = this.additionalLine;
        return data;
    }

    clone(): Organization {
        const json = this.toJSON();
        let result = new Organization();
        result.init(json);
        return result;
    }
}

/** An example of a valid address */
export interface IOrganization {
    street?: string;
    number?: string;
    city?: string;
    plz?: string;
    additionalLine?: string;

    [key: string]: any;
}

/** An example of a Hopps Organization, i.e. Verein */
export class Organization1 implements IOrganization1 {
    id?: number;
    name!: string;
    slug!: string;
    type!: TYPE;
    address?: Organization;
    rootBommel?: Bommel;
    members?: Member[];
    website?: string;
    profilePicture?: string;

    [key: string]: any;

    constructor(data?: IOrganization1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            this.address = _data["address"] ? Organization.fromJS(_data["address"]) : <any>undefined;
            this.rootBommel = _data["rootBommel"] ? Bommel.fromJS(_data["rootBommel"]) : <any>undefined;
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(Member.fromJS(item));
            }
            this.website = _data["website"];
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): Organization1 {
        data = typeof data === 'object' ? data : {};
        let result = new Organization1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["rootBommel"] = this.rootBommel ? this.rootBommel.toJSON() : <any>undefined;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item ? item.toJSON() : <any>undefined);
        }
        data["website"] = this.website;
        data["profilePicture"] = this.profilePicture;
        return data;
    }

    clone(): Organization1 {
        const json = this.toJSON();
        let result = new Organization1();
        result.init(json);
        return result;
    }
}

/** An example of a Hopps Organization, i.e. Verein */
export interface IOrganization1 {
    id?: number;
    name: string;
    slug: string;
    type: TYPE;
    address?: Organization;
    rootBommel?: Bommel;
    members?: Member[];
    website?: string;
    profilePicture?: string;

    [key: string]: any;
}

export class OrganizationInput implements IOrganizationInput {
    name?: string;
    slug?: string;
    type?: TYPE;
    website?: string;
    profilePicture?: string;
    address?: Organization;

    [key: string]: any;

    constructor(data?: IOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            this.website = _data["website"];
            this.profilePicture = _data["profilePicture"];
            this.address = _data["address"] ? Organization.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        data["website"] = this.website;
        data["profilePicture"] = this.profilePicture;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): OrganizationInput {
        const json = this.toJSON();
        let result = new OrganizationInput();
        result.init(json);
        return result;
    }
}

export interface IOrganizationInput {
    name?: string;
    slug?: string;
    type?: TYPE;
    website?: string;
    profilePicture?: string;
    address?: Organization;

    [key: string]: any;
}

export class OwnerInput implements IOwnerInput {
    email?: string;
    firstName?: string;
    lastName?: string;

    [key: string]: any;

    constructor(data?: IOwnerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): OwnerInput {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }

    clone(): OwnerInput {
        const json = this.toJSON();
        let result = new OwnerInput();
        result.init(json);
        return result;
    }
}

export interface IOwnerInput {
    email?: string;
    firstName?: string;
    lastName?: string;

    [key: string]: any;
}

export class ProcessMigrationSpec implements IProcessMigrationSpec {
    targetProcessId?: string;
    targetProcessVersion?: string;

    [key: string]: any;

    constructor(data?: IProcessMigrationSpec) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.targetProcessId = _data["targetProcessId"];
            this.targetProcessVersion = _data["targetProcessVersion"];
        }
    }

    static fromJS(data: any): ProcessMigrationSpec {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessMigrationSpec();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["targetProcessId"] = this.targetProcessId;
        data["targetProcessVersion"] = this.targetProcessVersion;
        return data;
    }

    clone(): ProcessMigrationSpec {
        const json = this.toJSON();
        let result = new ProcessMigrationSpec();
        result.init(json);
        return result;
    }
}

export interface IProcessMigrationSpec {
    targetProcessId?: string;
    targetProcessVersion?: string;

    [key: string]: any;
}

export class ReceiptData implements IReceiptData {
    referenceKey?: number;
    total?: number;
    storeName?: string | undefined;
    storeAddress?: StoreAddress;
    transactionTime?: TransactionTime;

    [key: string]: any;

    constructor(data?: IReceiptData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.referenceKey = _data["referenceKey"];
            this.total = _data["total"];
            this.storeName = _data["storeName"];
            this.storeAddress = _data["storeAddress"];
            this.transactionTime = _data["transactionTime"];
        }
    }

    static fromJS(data: any): ReceiptData {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiptData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["referenceKey"] = this.referenceKey;
        data["total"] = this.total;
        data["storeName"] = this.storeName;
        data["storeAddress"] = this.storeAddress;
        data["transactionTime"] = this.transactionTime;
        return data;
    }

    clone(): ReceiptData {
        const json = this.toJSON();
        let result = new ReceiptData();
        result.init(json);
        return result;
    }
}

export interface IReceiptData {
    referenceKey?: number;
    total?: number;
    storeName?: string | undefined;
    storeAddress?: StoreAddress;
    transactionTime?: TransactionTime;

    [key: string]: any;
}

export class ReceiptModelInput implements IReceiptModelInput {
    receiptData?: ReceiptData;

    [key: string]: any;

    constructor(data?: IReceiptModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.receiptData = _data["receiptData"] ? ReceiptData.fromJS(_data["receiptData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReceiptModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiptModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["receiptData"] = this.receiptData ? this.receiptData.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReceiptModelInput {
        const json = this.toJSON();
        let result = new ReceiptModelInput();
        result.init(json);
        return result;
    }
}

export interface IReceiptModelInput {
    receiptData?: ReceiptData;

    [key: string]: any;
}

export class ReceiptModelOutput implements IReceiptModelOutput {
    id?: string;
    receiptData?: ReceiptData;

    [key: string]: any;

    constructor(data?: IReceiptModelOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.receiptData = _data["receiptData"] ? ReceiptData.fromJS(_data["receiptData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReceiptModelOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiptModelOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["receiptData"] = this.receiptData ? this.receiptData.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReceiptModelOutput {
        const json = this.toJSON();
        let result = new ReceiptModelOutput();
        result.init(json);
        return result;
    }
}

export interface IReceiptModelOutput {
    id?: string;
    receiptData?: ReceiptData;

    [key: string]: any;
}

export class SourceFile implements ISourceFile {
    uri?: string;

    [key: string]: any;

    constructor(data?: ISourceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.uri = _data["uri"];
        }
    }

    static fromJS(data: any): SourceFile {
        data = typeof data === 'object' ? data : {};
        let result = new SourceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["uri"] = this.uri;
        return data;
    }

    clone(): SourceFile {
        const json = this.toJSON();
        let result = new SourceFile();
        result.init(json);
        return result;
    }
}

export interface ISourceFile {
    uri?: string;

    [key: string]: any;
}

export enum TYPE {
    EINGETRAGENER_VEREIN = "EINGETRAGENER_VEREIN",
}

export class TaskModel implements ITaskModel {
    id?: string;
    name?: string;
    state?: number;
    phase?: string;
    phaseStatus?: string;
    parameters?: any;
    results?: any;

    [key: string]: any;

    constructor(data?: ITaskModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"];
            this.phase = _data["phase"];
            this.phaseStatus = _data["phaseStatus"];
            this.parameters = _data["parameters"];
            this.results = _data["results"];
        }
    }

    static fromJS(data: any): TaskModel {
        data = typeof data === 'object' ? data : {};
        let result = new TaskModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["phase"] = this.phase;
        data["phaseStatus"] = this.phaseStatus;
        data["parameters"] = this.parameters;
        data["results"] = this.results;
        return data;
    }

    clone(): TaskModel {
        const json = this.toJSON();
        let result = new TaskModel();
        result.init(json);
        return result;
    }
}

export interface ITaskModel {
    id?: string;
    name?: string;
    state?: number;
    phase?: string;
    phaseStatus?: string;
    parameters?: any;
    results?: any;

    [key: string]: any;
}

export class TradeParty implements ITradeParty {
    id?: number;
    name?: string;
    country?: string;
    state?: string;
    city?: string;
    zipCode?: string;
    street?: string;
    additionalAddress?: string;
    taxID?: string;
    vatID?: string;
    description?: string;

    [key: string]: any;

    constructor(data?: ITradeParty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.street = _data["street"];
            this.additionalAddress = _data["additionalAddress"];
            this.taxID = _data["taxID"];
            this.vatID = _data["vatID"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TradeParty {
        data = typeof data === 'object' ? data : {};
        let result = new TradeParty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["street"] = this.street;
        data["additionalAddress"] = this.additionalAddress;
        data["taxID"] = this.taxID;
        data["vatID"] = this.vatID;
        data["description"] = this.description;
        return data;
    }

    clone(): TradeParty {
        const json = this.toJSON();
        let result = new TradeParty();
        result.init(json);
        return result;
    }
}

export interface ITradeParty {
    id?: number;
    name?: string;
    country?: string;
    state?: string;
    city?: string;
    zipCode?: string;
    street?: string;
    additionalAddress?: string;
    taxID?: string;
    vatID?: string;
    description?: string;

    [key: string]: any;
}

export class TransactionRecord implements ITransactionRecord {
    id?: number;
    bommelId?: number;
    documentKey?: string;
    uploader?: string;
    total?: number;
    privatelyPaid?: boolean;
    document?: DocumentType;
    transactionTime?: Date;
    sender?: TradeParty;
    recipient?: TradeParty;
    name?: string;
    orderNumber?: string;
    invoiceId?: string;
    dueDate?: Date;
    amountDue?: number;
    currencyCode?: string;

    [key: string]: any;

    constructor(data?: ITransactionRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.bommelId = _data["bommelId"];
            this.documentKey = _data["documentKey"];
            this.uploader = _data["uploader"];
            this.total = _data["total"];
            this.privatelyPaid = _data["privatelyPaid"];
            this.document = _data["document"];
            this.transactionTime = _data["transactionTime"] ? new Date(_data["transactionTime"].toString()) : <any>undefined;
            this.sender = _data["sender"] ? TradeParty.fromJS(_data["sender"]) : <any>undefined;
            this.recipient = _data["recipient"] ? TradeParty.fromJS(_data["recipient"]) : <any>undefined;
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
            this.invoiceId = _data["invoiceId"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.amountDue = _data["amountDue"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): TransactionRecord {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["bommelId"] = this.bommelId;
        data["documentKey"] = this.documentKey;
        data["uploader"] = this.uploader;
        data["total"] = this.total;
        data["privatelyPaid"] = this.privatelyPaid;
        data["document"] = this.document;
        data["transactionTime"] = this.transactionTime ? this.transactionTime.toISOString() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        data["invoiceId"] = this.invoiceId;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["amountDue"] = this.amountDue;
        data["currencyCode"] = this.currencyCode;
        return data;
    }

    clone(): TransactionRecord {
        const json = this.toJSON();
        let result = new TransactionRecord();
        result.init(json);
        return result;
    }
}

export interface ITransactionRecord {
    id?: number;
    bommelId?: number;
    documentKey?: string;
    uploader?: string;
    total?: number;
    privatelyPaid?: boolean;
    document?: DocumentType;
    transactionTime?: Date;
    sender?: TradeParty;
    recipient?: TradeParty;
    name?: string;
    orderNumber?: string;
    invoiceId?: string;
    dueDate?: Date;
    amountDue?: number;
    currencyCode?: string;

    [key: string]: any;
}

export class TreeSearchBommel implements ITreeSearchBommel {
    bommel?: Bommel;
    cyclePath?: number[];

    [key: string]: any;

    constructor(data?: ITreeSearchBommel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.bommel = _data["bommel"] ? Bommel.fromJS(_data["bommel"]) : <any>undefined;
            if (Array.isArray(_data["cyclePath"])) {
                this.cyclePath = [] as any;
                for (let item of _data["cyclePath"])
                    this.cyclePath!.push(item);
            }
        }
    }

    static fromJS(data: any): TreeSearchBommel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeSearchBommel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["bommel"] = this.bommel ? this.bommel.toJSON() : <any>undefined;
        if (Array.isArray(this.cyclePath)) {
            data["cyclePath"] = [];
            for (let item of this.cyclePath)
                data["cyclePath"].push(item);
        }
        return data;
    }

    clone(): TreeSearchBommel {
        const json = this.toJSON();
        let result = new TreeSearchBommel();
        result.init(json);
        return result;
    }
}

export interface ITreeSearchBommel {
    bommel?: Bommel;
    cyclePath?: number[];

    [key: string]: any;
}

export class ValidationResult implements IValidationResult {
    violations?: Violation[];

    [key: string]: any;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["violations"])) {
                this.violations = [] as any;
                for (let item of _data["violations"])
                    this.violations!.push(Violation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.violations)) {
            data["violations"] = [];
            for (let item of this.violations)
                data["violations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): ValidationResult {
        const json = this.toJSON();
        let result = new ValidationResult();
        result.init(json);
        return result;
    }
}

export interface IValidationResult {
    violations?: Violation[];

    [key: string]: any;
}

export class Violation implements IViolation {
    propertyPath?: string;
    message?: string;

    [key: string]: any;

    constructor(data?: IViolation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.propertyPath = _data["propertyPath"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Violation {
        data = typeof data === 'object' ? data : {};
        let result = new Violation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["propertyPath"] = this.propertyPath;
        data["message"] = this.message;
        return data;
    }

    clone(): Violation {
        const json = this.toJSON();
        let result = new Violation();
        result.init(json);
        return result;
    }
}

export interface IViolation {
    propertyPath?: string;
    message?: string;

    [key: string]: any;
}

export class DueDate implements IDueDate {

    [key: string]: any;

    constructor(data?: IDueDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): DueDate {
        data = typeof data === 'object' ? data : {};
        let result = new DueDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): DueDate {
        const json = this.toJSON();
        let result = new DueDate();
        result.init(json);
        return result;
    }
}

export interface IDueDate {

    [key: string]: any;
}

export class Sender implements ISender {

    [key: string]: any;

    constructor(data?: ISender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Sender {
        data = typeof data === 'object' ? data : {};
        let result = new Sender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): Sender {
        const json = this.toJSON();
        let result = new Sender();
        result.init(json);
        return result;
    }
}

export interface ISender {

    [key: string]: any;
}

export class Receiver implements IReceiver {

    [key: string]: any;

    constructor(data?: IReceiver) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Receiver {
        data = typeof data === 'object' ? data : {};
        let result = new Receiver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): Receiver {
        const json = this.toJSON();
        let result = new Receiver();
        result.init(json);
        return result;
    }
}

export interface IReceiver {

    [key: string]: any;
}

export class StoreAddress implements IStoreAddress {

    [key: string]: any;

    constructor(data?: IStoreAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): StoreAddress {
        data = typeof data === 'object' ? data : {};
        let result = new StoreAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): StoreAddress {
        const json = this.toJSON();
        let result = new StoreAddress();
        result.init(json);
        return result;
    }
}

export interface IStoreAddress {

    [key: string]: any;
}

export class TransactionTime implements ITransactionTime {

    [key: string]: any;

    constructor(data?: ITransactionTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): TransactionTime {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): TransactionTime {
        const json = this.toJSON();
        let result = new TransactionTime();
        result.init(json);
        return result;
    }
}

export interface ITransactionTime {

    [key: string]: any;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}