//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Bommel_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Create bommel
     * @return Bommel successfully created
     */
    bommelPOST(body: Bommel): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPOST(_response);
        });
    }

    protected processBommelPOST(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Bommel.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bommel has no parent, cannot create root-bommel", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Move a bommel underneath a different parent
     * @return Bommel successfully moved
     */
    to(id: number, newParentId: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/move/{id}/to/{newParentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (newParentId === undefined || newParentId === null)
            throw new Error("The parameter 'newParentId' must be defined.");
        url_ = url_.replace("{newParentId}", encodeURIComponent("" + newParentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTo(_response);
        });
    }

    protected processTo(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized to move bommel", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("<li>Bommel not found <li>New parent bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Fetch root-bommel for organization
     * @return Root-Bommel found
     */
    root(orgId: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/root/{orgId}";
        if (orgId === undefined || orgId === null)
            throw new Error("The parameter 'orgId' must be defined.");
        url_ = url_.replace("{orgId}", encodeURIComponent("" + orgId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoot(_response);
        });
    }

    protected processRoot(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Update bommel
     * @return Bommel successfully updated
     */
    bommelPUT(id: number, body: Bommel): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPUT(_response);
        });
    }

    protected processBommelPUT(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Fetch a bommel by its id
     * @return Bommel found
     */
    bommelGET(id: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelGET(_response);
        });
    }

    protected processBommelGET(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Delete bommel
     * @param recursive (optional) 
     * @return Bommel successfully deleted
     */
    bommelDELETE(id: number, recursive: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/bommel/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (recursive === null)
            throw new Error("The parameter 'recursive' cannot be null.");
        else if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelDELETE(_response);
        });
    }

    protected processBommelDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Fetch the children of bommel
     * @return Children of bommel
     */
    children(id: number): Promise<Bommel[]> {
        let url_ = this.baseUrl + "/bommel/{id}/children";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChildren(_response);
        });
    }

    protected processChildren(response: Response): Promise<Bommel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Bommel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel[]>(null as any);
    }

    /**
     * Fetch the children of bommel recursively
     * @return Recursive children of bommel
     */
    recursive(id: number): Promise<TreeSearchBommel[]> {
        let url_ = this.baseUrl + "/bommel/{id}/children/recursive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecursive(_response);
        });
    }

    protected processRecursive(response: Response): Promise<TreeSearchBommel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeSearchBommel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreeSearchBommel[]>(null as any);
    }
}

export class Process_Instance_Management_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Get Processes
     * @return OK
     */
    processes(): Promise<void> {
        let url_ = this.baseUrl + "/management/processes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcesses(_response);
        });
    }

    protected processProcesses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Process Info
     * @return OK
     */
    processes2(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcesses2(_response);
        });
    }

    protected processProcesses2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Cancel Process Instance Id
     * @return OK
     */
    instancesDELETE(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesDELETE(_response);
        });
    }

    protected processInstancesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Instance In Error
     * @return OK
     */
    error(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/error";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processError(_response);
        });
    }

    protected processError(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Migrate Instance
     * @return OK
     */
    migrate(processId: string, processInstanceId: string, body: ProcessMigrationSpec): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/migrate";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMigrate(_response);
        });
    }

    protected processMigrate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Work Items In Process Instance
     * @return OK
     */
    nodeInstancesGET(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodeInstances";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodeInstancesGET(_response);
        });
    }

    protected processNodeInstancesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retrigger Node Instance Id
     * @return OK
     */
    nodeInstancesPOST(nodeInstanceId: string, processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodeInstances/{nodeInstanceId}";
        if (nodeInstanceId === undefined || nodeInstanceId === null)
            throw new Error("The parameter 'nodeInstanceId' must be defined.");
        url_ = url_.replace("{nodeInstanceId}", encodeURIComponent("" + nodeInstanceId));
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodeInstancesPOST(_response);
        });
    }

    protected processNodeInstancesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Cancel Node Instance Id
     * @return OK
     */
    nodeInstancesDELETE(nodeInstanceId: string, processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodeInstances/{nodeInstanceId}";
        if (nodeInstanceId === undefined || nodeInstanceId === null)
            throw new Error("The parameter 'nodeInstanceId' must be defined.");
        url_ = url_.replace("{nodeInstanceId}", encodeURIComponent("" + nodeInstanceId));
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodeInstancesDELETE(_response);
        });
    }

    protected processNodeInstancesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Trigger Node Instance Id
     * @return OK
     */
    nodesPOST(nodeId: string, processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/nodes/{nodeId}";
        if (nodeId === undefined || nodeId === null)
            throw new Error("The parameter 'nodeId' must be defined.");
        url_ = url_.replace("{nodeId}", encodeURIComponent("" + nodeId));
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodesPOST(_response);
        });
    }

    protected processNodesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retrigger Instance In Error
     * @return OK
     */
    retrigger(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/retrigger";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrigger(_response);
        });
    }

    protected processRetrigger(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Skip Instance In Error
     * @return OK
     */
    skip(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/instances/{processInstanceId}/skip";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSkip(_response);
        });
    }

    protected processSkip(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Migrate All Instances
     * @return OK
     */
    migrate2(processId: string, body: ProcessMigrationSpec): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/migrate";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMigrate2(_response);
        });
    }

    protected processMigrate2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Process Nodes
     * @return OK
     */
    nodesGET(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/nodes";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNodesGET(_response);
        });
    }

    protected processNodesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Source_Files_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Get Source File By Uri
     * @param uri (optional) 
     * @return OK
     */
    sources(uri: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/sources?";
        if (uri === null)
            throw new Error("The parameter 'uri' cannot be null.");
        else if (uri !== undefined)
            url_ += "uri=" + encodeURIComponent("" + uri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSources(_response);
        });
    }

    protected processSources(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Source File By Process Id
     * @return OK
     */
    source(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/management/processes/{processId}/source";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSource(_response);
        });
    }

    protected processSource(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Source Files By Process Id
     * @return OK
     */
    sourcesAll(processId: string): Promise<SourceFile[]> {
        let url_ = this.baseUrl + "/management/processes/{processId}/sources";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSourcesAll(_response);
        });
    }

    protected processSourcesAll(response: Response): Promise<SourceFile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SourceFile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SourceFile[]>(null as any);
    }
}

export class Member_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Validates the member input
     * @return Validation successful
     */
    validate(body: Member): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/member/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation failed", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }
}

export class Quarkus_Topics_Information_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Get Topics
     * @return OK
     */
    topics(): Promise<void> {
        let url_ = this.baseUrl + "/messaging/topics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTopics(_response);
        });
    }

    protected processTopics(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Organization_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Create a new organization
     * @return Creation started successfully
     */
    organizationPOST(body: NewOrganizationInput): Promise<CreateOrganizationResponse> {
        let url_ = this.baseUrl + "/organization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationPOST(_response);
        });
    }

    protected processOrganizationPOST(response: Response): Promise<CreateOrganizationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = CreateOrganizationResponse.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation of fields failed", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = CreateOrganizationResponse.fromJS(resultData500);
            return throwException("Process failed", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateOrganizationResponse>(null as any);
    }

    /**
     * Get my organization
     * @return Own organization retrieved successfully
     */
    my(): Promise<Organization1> {
        let url_ = this.baseUrl + "/organization/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMy(_response);
        });
    }

    protected processMy(response: Response): Promise<Organization1> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization1.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for user", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization1>(null as any);
    }

    /**
     * Validates the organization input
     * @return Validation successful
     */
    validate2(body: Organization1): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/organization/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate2(_response);
        });
    }

    protected processValidate2(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation failed", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }

    /**
     * Get organization
     * @return Organization retrieved successfully
     */
    organizationGET(slug: string): Promise<Organization1> {
        let url_ = this.baseUrl + "/organization/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationGET(_response);
        });
    }

    protected processOrganizationGET(response: Response): Promise<Organization1> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization1.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for provided slug", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization1>(null as any);
    }

    /**
     * Get organization members
     * @return Members retrieved successfully
     */
    members(slug: string): Promise<Member[]> {
        let url_ = this.baseUrl + "/organization/{slug}/members";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers(_response);
        });
    }

    protected processMembers(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for provided slug", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(null as any);
    }
}

export class Process_Svg_ResourceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Get Process Svg
     * @return OK
     */
    processes3(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/svg/processes/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcesses3(_response);
        });
    }

    protected processProcesses3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get Execution Path By Process Instance Id
     * @return OK
     */
    instancesGET(processId: string, processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/svg/processes/{processId}/instances/{processInstanceId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{processInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesGET(_response);
        });
    }

    protected processInstancesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Bommel implements IBommel {
    id?: number;
    name?: string;
    emoji?: string;
    responsibleMember?: Member;
    organization?: Organization1;
    parent?: Bommel;
    children?: Bommel[];

    [key: string]: any;

    constructor(data?: IBommel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.emoji = _data["emoji"];
            this.responsibleMember = _data["responsibleMember"] ? Member.fromJS(_data["responsibleMember"]) : <any>undefined;
            this.organization = _data["organization"] ? Organization1.fromJS(_data["organization"]) : <any>undefined;
            this.parent = _data["parent"] ? Bommel.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Bommel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Bommel {
        data = typeof data === 'object' ? data : {};
        let result = new Bommel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["emoji"] = this.emoji;
        data["responsibleMember"] = this.responsibleMember ? this.responsibleMember.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): Bommel {
        const json = this.toJSON();
        let result = new Bommel();
        result.init(json);
        return result;
    }
}

export interface IBommel {
    id?: number;
    name?: string;
    emoji?: string;
    responsibleMember?: Member;
    organization?: Organization1;
    parent?: Bommel;
    children?: Bommel[];

    [key: string]: any;
}

export class CreateOrganizationResponse implements ICreateOrganizationResponse {
    id?: string;
    error?: string;

    [key: string]: any;

    constructor(data?: ICreateOrganizationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): CreateOrganizationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["error"] = this.error;
        return data;
    }

    clone(): CreateOrganizationResponse {
        const json = this.toJSON();
        let result = new CreateOrganizationResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationResponse {
    id?: string;
    error?: string;

    [key: string]: any;
}

/** An example of a Hopps Member */
export class Member implements IMember {
    id?: number;
    /** First Name of the Member */
    firstName!: string;
    /** Last Name of the Member */
    lastName!: string;
    email!: string;
    organizations?: Organization1[];

    [key: string]: any;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(Organization1.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): Member {
        const json = this.toJSON();
        let result = new Member();
        result.init(json);
        return result;
    }
}

/** An example of a Hopps Member */
export interface IMember {
    id?: number;
    /** First Name of the Member */
    firstName: string;
    /** Last Name of the Member */
    lastName: string;
    email: string;
    organizations?: Organization1[];

    [key: string]: any;
}

export class NewOrganizationInput implements INewOrganizationInput {
    owner!: OwnerInput;
    newPassword!: string;
    organization!: OrganizationInput;

    [key: string]: any;

    constructor(data?: INewOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.owner = new OwnerInput();
            this.organization = new OrganizationInput();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.owner = _data["owner"] ? OwnerInput.fromJS(_data["owner"]) : new OwnerInput();
            this.newPassword = _data["newPassword"];
            this.organization = _data["organization"] ? OrganizationInput.fromJS(_data["organization"]) : new OrganizationInput();
        }
    }

    static fromJS(data: any): NewOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["newPassword"] = this.newPassword;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data;
    }

    clone(): NewOrganizationInput {
        const json = this.toJSON();
        let result = new NewOrganizationInput();
        result.init(json);
        return result;
    }
}

export interface INewOrganizationInput {
    owner: OwnerInput;
    newPassword: string;
    organization: OrganizationInput;

    [key: string]: any;
}

export class NewOrganizationModelInput implements INewOrganizationModelInput {
    owner?: Member;
    organization?: Organization1;
    newPassword?: string;

    [key: string]: any;

    constructor(data?: INewOrganizationModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.owner = _data["owner"] ? Member.fromJS(_data["owner"]) : <any>undefined;
            this.organization = _data["organization"] ? Organization1.fromJS(_data["organization"]) : <any>undefined;
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): NewOrganizationModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): NewOrganizationModelInput {
        const json = this.toJSON();
        let result = new NewOrganizationModelInput();
        result.init(json);
        return result;
    }
}

export interface INewOrganizationModelInput {
    owner?: Member;
    organization?: Organization1;
    newPassword?: string;

    [key: string]: any;
}

export class NewOrganizationModelOutput implements INewOrganizationModelOutput {
    id?: string;

    [key: string]: any;

    constructor(data?: INewOrganizationModelOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NewOrganizationModelOutput {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationModelOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }

    clone(): NewOrganizationModelOutput {
        const json = this.toJSON();
        let result = new NewOrganizationModelOutput();
        result.init(json);
        return result;
    }
}

export interface INewOrganizationModelOutput {
    id?: string;

    [key: string]: any;
}

/** An example of a valid address */
export class Organization implements IOrganization {
    street?: string;
    number?: string;
    city?: string;
    plz?: string;
    additionalLine?: string;

    [key: string]: any;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.street = _data["street"];
            this.number = _data["number"];
            this.city = _data["city"];
            this.plz = _data["plz"];
            this.additionalLine = _data["additionalLine"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["street"] = this.street;
        data["number"] = this.number;
        data["city"] = this.city;
        data["plz"] = this.plz;
        data["additionalLine"] = this.additionalLine;
        return data;
    }

    clone(): Organization {
        const json = this.toJSON();
        let result = new Organization();
        result.init(json);
        return result;
    }
}

/** An example of a valid address */
export interface IOrganization {
    street?: string;
    number?: string;
    city?: string;
    plz?: string;
    additionalLine?: string;

    [key: string]: any;
}

/** An example of a Hopps Organization, i.e. Verein */
export class Organization1 implements IOrganization1 {
    id?: number;
    name!: string;
    slug!: string;
    type!: TYPE;
    address?: Organization;
    rootBommel?: Bommel;
    members?: Member[];
    website?: string;
    profilePicture?: string;

    [key: string]: any;

    constructor(data?: IOrganization1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            this.address = _data["address"] ? Organization.fromJS(_data["address"]) : <any>undefined;
            this.rootBommel = _data["rootBommel"] ? Bommel.fromJS(_data["rootBommel"]) : <any>undefined;
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(Member.fromJS(item));
            }
            this.website = _data["website"];
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): Organization1 {
        data = typeof data === 'object' ? data : {};
        let result = new Organization1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["rootBommel"] = this.rootBommel ? this.rootBommel.toJSON() : <any>undefined;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item ? item.toJSON() : <any>undefined);
        }
        data["website"] = this.website;
        data["profilePicture"] = this.profilePicture;
        return data;
    }

    clone(): Organization1 {
        const json = this.toJSON();
        let result = new Organization1();
        result.init(json);
        return result;
    }
}

/** An example of a Hopps Organization, i.e. Verein */
export interface IOrganization1 {
    id?: number;
    name: string;
    slug: string;
    type: TYPE;
    address?: Organization;
    rootBommel?: Bommel;
    members?: Member[];
    website?: string;
    profilePicture?: string;

    [key: string]: any;
}

export class OrganizationInput implements IOrganizationInput {
    name?: string;
    slug?: string;
    type?: TYPE;
    website?: string;
    profilePicture?: string;
    address?: Organization;

    [key: string]: any;

    constructor(data?: IOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            this.website = _data["website"];
            this.profilePicture = _data["profilePicture"];
            this.address = _data["address"] ? Organization.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        data["website"] = this.website;
        data["profilePicture"] = this.profilePicture;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): OrganizationInput {
        const json = this.toJSON();
        let result = new OrganizationInput();
        result.init(json);
        return result;
    }
}

export interface IOrganizationInput {
    name?: string;
    slug?: string;
    type?: TYPE;
    website?: string;
    profilePicture?: string;
    address?: Organization;

    [key: string]: any;
}

export class OwnerInput implements IOwnerInput {
    email?: string;
    firstName?: string;
    lastName?: string;

    [key: string]: any;

    constructor(data?: IOwnerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): OwnerInput {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }

    clone(): OwnerInput {
        const json = this.toJSON();
        let result = new OwnerInput();
        result.init(json);
        return result;
    }
}

export interface IOwnerInput {
    email?: string;
    firstName?: string;
    lastName?: string;

    [key: string]: any;
}

export class ProcessMigrationSpec implements IProcessMigrationSpec {
    targetProcessId?: string;
    targetProcessVersion?: string;

    [key: string]: any;

    constructor(data?: IProcessMigrationSpec) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.targetProcessId = _data["targetProcessId"];
            this.targetProcessVersion = _data["targetProcessVersion"];
        }
    }

    static fromJS(data: any): ProcessMigrationSpec {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessMigrationSpec();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["targetProcessId"] = this.targetProcessId;
        data["targetProcessVersion"] = this.targetProcessVersion;
        return data;
    }

    clone(): ProcessMigrationSpec {
        const json = this.toJSON();
        let result = new ProcessMigrationSpec();
        result.init(json);
        return result;
    }
}

export interface IProcessMigrationSpec {
    targetProcessId?: string;
    targetProcessVersion?: string;

    [key: string]: any;
}

export class SourceFile implements ISourceFile {
    uri?: string;

    [key: string]: any;

    constructor(data?: ISourceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.uri = _data["uri"];
        }
    }

    static fromJS(data: any): SourceFile {
        data = typeof data === 'object' ? data : {};
        let result = new SourceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["uri"] = this.uri;
        return data;
    }

    clone(): SourceFile {
        const json = this.toJSON();
        let result = new SourceFile();
        result.init(json);
        return result;
    }
}

export interface ISourceFile {
    uri?: string;

    [key: string]: any;
}

export enum TYPE {
    EINGETRAGENER_VEREIN = "EINGETRAGENER_VEREIN",
}

export class TaskModel implements ITaskModel {
    id?: string;
    name?: string;
    state?: number;
    phase?: string;
    phaseStatus?: string;
    parameters?: any;
    results?: any;

    [key: string]: any;

    constructor(data?: ITaskModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"];
            this.phase = _data["phase"];
            this.phaseStatus = _data["phaseStatus"];
            this.parameters = _data["parameters"];
            this.results = _data["results"];
        }
    }

    static fromJS(data: any): TaskModel {
        data = typeof data === 'object' ? data : {};
        let result = new TaskModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["phase"] = this.phase;
        data["phaseStatus"] = this.phaseStatus;
        data["parameters"] = this.parameters;
        data["results"] = this.results;
        return data;
    }

    clone(): TaskModel {
        const json = this.toJSON();
        let result = new TaskModel();
        result.init(json);
        return result;
    }
}

export interface ITaskModel {
    id?: string;
    name?: string;
    state?: number;
    phase?: string;
    phaseStatus?: string;
    parameters?: any;
    results?: any;

    [key: string]: any;
}

export class TreeSearchBommel implements ITreeSearchBommel {
    bommel?: Bommel;
    cyclePath?: number[];

    [key: string]: any;

    constructor(data?: ITreeSearchBommel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.bommel = _data["bommel"] ? Bommel.fromJS(_data["bommel"]) : <any>undefined;
            if (Array.isArray(_data["cyclePath"])) {
                this.cyclePath = [] as any;
                for (let item of _data["cyclePath"])
                    this.cyclePath!.push(item);
            }
        }
    }

    static fromJS(data: any): TreeSearchBommel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeSearchBommel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["bommel"] = this.bommel ? this.bommel.toJSON() : <any>undefined;
        if (Array.isArray(this.cyclePath)) {
            data["cyclePath"] = [];
            for (let item of this.cyclePath)
                data["cyclePath"].push(item);
        }
        return data;
    }

    clone(): TreeSearchBommel {
        const json = this.toJSON();
        let result = new TreeSearchBommel();
        result.init(json);
        return result;
    }
}

export interface ITreeSearchBommel {
    bommel?: Bommel;
    cyclePath?: number[];

    [key: string]: any;
}

export class ValidationResult implements IValidationResult {
    violations?: Violation[];

    [key: string]: any;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["violations"])) {
                this.violations = [] as any;
                for (let item of _data["violations"])
                    this.violations!.push(Violation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.violations)) {
            data["violations"] = [];
            for (let item of this.violations)
                data["violations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): ValidationResult {
        const json = this.toJSON();
        let result = new ValidationResult();
        result.init(json);
        return result;
    }
}

export interface IValidationResult {
    violations?: Violation[];

    [key: string]: any;
}

export class Violation implements IViolation {
    propertyPath?: string;
    message?: string;

    [key: string]: any;

    constructor(data?: IViolation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.propertyPath = _data["propertyPath"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Violation {
        data = typeof data === 'object' ? data : {};
        let result = new Violation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["propertyPath"] = this.propertyPath;
        data["message"] = this.message;
        return data;
    }

    clone(): Violation {
        const json = this.toJSON();
        let result = new Violation();
        result.init(json);
        return result;
    }
}

export interface IViolation {
    propertyPath?: string;
    message?: string;

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}