//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8101";
    }

    /**
     * Get all transaction records
     * @param bommelId (optional) Fetch all transaction records which are connected to the bommel
     * @param detached (optional) Fetch all transaction records which are not connected to any bommel
     * @param page (optional) Current page you want to display, starts with 0
     * @param size (optional) 
     * @return List of transaction records, empty list if none are available
     */
    all(bommelId: number | undefined, detached: boolean | undefined, page: number | undefined, size: number | undefined): Promise<TransactionRecord[]> {
        let url_ = this.baseUrl + "/all?";
        if (bommelId === null)
            throw new Error("The parameter 'bommelId' cannot be null.");
        else if (bommelId !== undefined)
            url_ += "bommelId=" + encodeURIComponent("" + bommelId) + "&";
        if (detached === null)
            throw new Error("The parameter 'detached' cannot be null.");
        else if (detached !== undefined)
            url_ += "detached=" + encodeURIComponent("" + detached) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: Response): Promise<TransactionRecord[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionRecord.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionRecord[]>(null as any);
    }

    /**
     * Create bommel
     * @return Bommel successfully created
     */
    bommelPOST(body: Bommel): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPOST(_response);
        });
    }

    protected processBommelPOST(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Bommel.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bommel has no parent, cannot create root-bommel", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Move a bommel underneath a different parent
     * @return Bommel successfully moved
     */
    to(id: number, newParentId: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/move/{id}/to/{newParentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (newParentId === undefined || newParentId === null)
            throw new Error("The parameter 'newParentId' must be defined.");
        url_ = url_.replace("{newParentId}", encodeURIComponent("" + newParentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTo(_response);
        });
    }

    protected processTo(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized to move bommel", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("<li>Bommel not found <li>New parent bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Fetch all bommels for user's organization
     * @return All bommels for organization
     */
    organizationAll(): Promise<TreeSearchBommel[]> {
        let url_ = this.baseUrl + "/bommel/organization";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationAll(_response);
        });
    }

    protected processOrganizationAll(response: Response): Promise<TreeSearchBommel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeSearchBommel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization or root bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreeSearchBommel[]>(null as any);
    }

    /**
     * Fetch root-bommel for organization
     * @return Root-Bommel found
     */
    root(orgId: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/root/{orgId}";
        if (orgId === undefined || orgId === null)
            throw new Error("The parameter 'orgId' must be defined.");
        url_ = url_.replace("{orgId}", encodeURIComponent("" + orgId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoot(_response);
        });
    }

    protected processRoot(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Update bommel
     * @return Bommel successfully updated
     */
    bommelPUT(id: number, body: Bommel): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPUT(_response);
        });
    }

    protected processBommelPUT(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Fetch a bommel by its id
     * @return Bommel found
     */
    bommelGET(id: number): Promise<Bommel> {
        let url_ = this.baseUrl + "/bommel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelGET(_response);
        });
    }

    protected processBommelGET(response: Response): Promise<Bommel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bommel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel>(null as any);
    }

    /**
     * Delete bommel
     * @param recursive (optional) 
     * @return Bommel successfully deleted
     */
    bommelDELETE(id: number, recursive: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/bommel/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (recursive === null)
            throw new Error("The parameter 'recursive' cannot be null.");
        else if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelDELETE(_response);
        });
    }

    protected processBommelDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Fetch the children of bommel
     * @return Children of bommel
     */
    children(id: number): Promise<Bommel[]> {
        let url_ = this.baseUrl + "/bommel/{id}/children";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChildren(_response);
        });
    }

    protected processChildren(response: Response): Promise<Bommel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Bommel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Bommel[]>(null as any);
    }

    /**
     * Fetch the children of bommel recursively
     * @return Recursive children of bommel
     */
    recursive(id: number): Promise<TreeSearchBommel[]> {
        let url_ = this.baseUrl + "/bommel/{id}/children/recursive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecursive(_response);
        });
    }

    protected processRecursive(response: Response): Promise<TreeSearchBommel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeSearchBommel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("User not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User not authorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Bommel not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TreeSearchBommel[]>(null as any);
    }

    /**
     * Get all categories for user's organization
     * @return Categories retrieved successfully
     */
    categoryAll(): Promise<Category[]> {
        let url_ = this.baseUrl + "/category";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoryAll(_response);
        });
    }

    protected processCategoryAll(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or organization not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(null as any);
    }

    /**
     * Create a new category
     * @return Category created successfully
     */
    categoryPOST(body: CategoryInput): Promise<Category> {
        let url_ = this.baseUrl + "/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoryPOST(_response);
        });
    }

    protected processCategoryPOST(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Category.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid category data", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or organization not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * Update a category
     * @return Category updated successfully
     */
    categoryPUT(id: number, body: CategoryInput): Promise<Category> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoryPUT(_response);
        });
    }

    protected processCategoryPUT(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Category not found or not accessible", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid category data", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * Get category by ID
     * @return Category retrieved successfully
     */
    categoryGET(id: number): Promise<Category> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoryGET(_response);
        });
    }

    protected processCategoryGET(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Category not found or not accessible", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * Delete a category
     * @return Category deleted successfully
     */
    categoryDELETE(id: number): Promise<void> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategoryDELETE(_response);
        });
    }

    protected processCategoryDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Category not found or not accessible", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Upload a document
     * @param file (optional) 
     * @return Document created successfully
     */
    documentsPOST(file: FileParameter | undefined): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/documents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentsPOST(_response);
        });
    }

    protected processDocumentsPOST(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DocumentResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input (missing file, invalid bommel, or unsupported file type)", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * List all documents
     * @param bommelId (optional) Filter by bommel ID
     * @return List of documents
     */
    documentsAll(bommelId: number | undefined): Promise<DocumentResponse[]> {
        let url_ = this.baseUrl + "/documents?";
        if (bommelId === null)
            throw new Error("The parameter 'bommelId' cannot be null.");
        else if (bommelId !== undefined)
            url_ += "bommelId=" + encodeURIComponent("" + bommelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentsAll(_response);
        });
    }

    protected processDocumentsAll(response: Response): Promise<DocumentResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse[]>(null as any);
    }

    /**
     * Update a document
     * @param id Document ID
     * @return Document updated
     */
    documentsPATCH(id: number, body: DocumentUpdateRequest): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentsPATCH(_response);
        });
    }

    protected processDocumentsPATCH(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Document not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * Get a document
     * @param id Document ID
     * @return Document found
     */
    documentsGET(id: number): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentsGET(_response);
        });
    }

    protected processDocumentsGET(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Document not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * Delete a document
     * @param id Document ID
     * @return Document deleted
     */
    documentsDELETE(id: number): Promise<void> {
        let url_ = this.baseUrl + "/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentsDELETE(_response);
        });
    }

    protected processDocumentsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Document not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Download document file
     * @param id Document ID
     * @return File content
     */
    file(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/documents/{id}/file";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFile(_response);
        });
    }

    protected processFile(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Document or file not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Re-analyze a document
     * @param id Document ID
     * @return Analysis started
     */
    reanalyze(id: number): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/documents/{id}/reanalyze";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReanalyze(_response);
        });
    }

    protected processReanalyze(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Document not found", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Document has no file to analyze", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * Validates the member input
     * @return Validation successful
     */
    validate(body: Member): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/member/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation failed", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }

    /**
     * Create a new organization
     * @return Organization created successfully
     */
    organizationPOST(body: NewOrganizationInput): Promise<Organization> {
        let url_ = this.baseUrl + "/organization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationPOST(_response);
        });
    }

    protected processOrganizationPOST(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Organization.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation of fields failed", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Email or slug already exists", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(null as any);
    }

    /**
     * Get my organization
     * @return Own organization retrieved successfully
     */
    my(): Promise<Organization> {
        let url_ = this.baseUrl + "/organization/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMy(_response);
        });
    }

    protected processMy(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for user", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(null as any);
    }

    /**
     * Validates the organization input
     * @return Validation successful
     */
    validate2(body: Organization): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/organization/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate2(_response);
        });
    }

    protected processValidate2(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResult.fromJS(resultData400);
            return throwException("Validation failed", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }

    /**
     * Get organization
     * @return Organization retrieved successfully
     */
    organizationGET(slug: string): Promise<Organization> {
        let url_ = this.baseUrl + "/organization/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationGET(_response);
        });
    }

    protected processOrganizationGET(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for provided slug", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(null as any);
    }

    /**
     * Get organization members
     * @return Members retrieved successfully
     */
    members(slug: string): Promise<Member[]> {
        let url_ = this.baseUrl + "/organization/{slug}/members";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers(_response);
        });
    }

    protected processMembers(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Organization not found for provided slug", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(null as any);
    }

    /**
     * Add a transaction record to a bommel
     * @param bommelId (optional) 
     * @return Specified transaction record was attached to bommel
     */
    bommelPATCH(id: number, bommelId: number | undefined): Promise<any> {
        let url_ = this.baseUrl + "/{id}/bommel?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (bommelId === null)
            throw new Error("The parameter 'bommelId' cannot be null.");
        else if (bommelId !== undefined)
            url_ += "bommelId=" + encodeURIComponent("" + bommelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBommelPATCH(_response);
        });
    }

    protected processBommelPATCH(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Specified transaction record id was not found", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bommel was not found", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Not Authorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Not Allowed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

/** An example of a valid address */
export class Address implements IAddress {
    street?: string;
    number?: string;
    city?: string;
    plz?: string;
    additionalLine?: string;

    [key: string]: any;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.street = _data["street"];
            this.number = _data["number"];
            this.city = _data["city"];
            this.plz = _data["plz"];
            this.additionalLine = _data["additionalLine"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["street"] = this.street;
        data["number"] = this.number;
        data["city"] = this.city;
        data["plz"] = this.plz;
        data["additionalLine"] = this.additionalLine;
        return data;
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

/** An example of a valid address */
export interface IAddress {
    street?: string;
    number?: string;
    city?: string;
    plz?: string;
    additionalLine?: string;

    [key: string]: any;
}

export type AnalysisStatus = "PENDING" | "ANALYZING" | "COMPLETED" | "FAILED" | "SKIPPED";

export class Bommel implements IBommel {
    id?: number;
    name?: string;
    emoji?: string;
    responsibleMember?: Member;
    organization?: Organization;
    parent?: Bommel;
    children?: Bommel[];

    [key: string]: any;

    constructor(data?: IBommel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.emoji = _data["emoji"];
            this.responsibleMember = _data["responsibleMember"] ? Member.fromJS(_data["responsibleMember"]) : <any>undefined;
            this.organization = _data["organization"] ? Organization.fromJS(_data["organization"]) : <any>undefined;
            this.parent = _data["parent"] ? Bommel.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Bommel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Bommel {
        data = typeof data === 'object' ? data : {};
        let result = new Bommel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["emoji"] = this.emoji;
        data["responsibleMember"] = this.responsibleMember ? this.responsibleMember.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): Bommel {
        const json = this.toJSON();
        let result = new Bommel();
        result.init(json);
        return result;
    }
}

export interface IBommel {
    id?: number;
    name?: string;
    emoji?: string;
    responsibleMember?: Member;
    organization?: Organization;
    parent?: Bommel;
    children?: Bommel[];

    [key: string]: any;
}

/** A category for organizing content or entities */
export class Category implements ICategory {
    id?: number;
    name!: string;
    description?: string;
    /** The organization this category belongs to */
    organization!: Organization;

    [key: string]: any;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.organization = new Organization();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.organization = _data["organization"] ? Organization.fromJS(_data["organization"]) : new Organization();
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data;
    }

    clone(): Category {
        const json = this.toJSON();
        let result = new Category();
        result.init(json);
        return result;
    }
}

/** A category for organizing content or entities */
export interface ICategory {
    id?: number;
    name: string;
    description?: string;
    /** The organization this category belongs to */
    organization: Organization;

    [key: string]: any;
}

/** Input for creating a new category */
export class CategoryInput implements ICategoryInput {
    /** Name of the category */
    name!: string;
    /** Description of the category */
    description?: string;

    [key: string]: any;

    constructor(data?: ICategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }

    clone(): CategoryInput {
        const json = this.toJSON();
        let result = new CategoryInput();
        result.init(json);
        return result;
    }
}

/** Input for creating a new category */
export interface ICategoryInput {
    /** Name of the category */
    name: string;
    /** Description of the category */
    description?: string;

    [key: string]: any;
}

export class DocumentResponse implements IDocumentResponse {
    id?: number;
    fileName?: string;
    fileContentType?: string;
    fileSize?: number;
    bommelId?: number;
    documentType?: DocumentType;
    privatelyPaid?: boolean;
    analysisStatus?: AnalysisStatus;
    analysisError?: string;
    extractionSource?: ExtractionSource;
    name?: string;
    total?: number;
    totalTax?: number;
    currencyCode?: string;
    transactionTime?: Date;
    senderName?: string;
    senderStreet?: string;
    senderZipCode?: string;
    senderCity?: string;
    tags?: string[];
    createdAt?: Date;
    uploadedBy?: string;

    [key: string]: any;

    constructor(data?: IDocumentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.fileContentType = _data["fileContentType"];
            this.fileSize = _data["fileSize"];
            this.bommelId = _data["bommelId"];
            this.documentType = _data["documentType"];
            this.privatelyPaid = _data["privatelyPaid"];
            this.analysisStatus = _data["analysisStatus"];
            this.analysisError = _data["analysisError"];
            this.extractionSource = _data["extractionSource"];
            this.name = _data["name"];
            this.total = _data["total"];
            this.totalTax = _data["totalTax"];
            this.currencyCode = _data["currencyCode"];
            this.transactionTime = _data["transactionTime"] ? new Date(_data["transactionTime"].toString()) : <any>undefined;
            this.senderName = _data["senderName"];
            this.senderStreet = _data["senderStreet"];
            this.senderZipCode = _data["senderZipCode"];
            this.senderCity = _data["senderCity"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.uploadedBy = _data["uploadedBy"];
        }
    }

    static fromJS(data: any): DocumentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["fileContentType"] = this.fileContentType;
        data["fileSize"] = this.fileSize;
        data["bommelId"] = this.bommelId;
        data["documentType"] = this.documentType;
        data["privatelyPaid"] = this.privatelyPaid;
        data["analysisStatus"] = this.analysisStatus;
        data["analysisError"] = this.analysisError;
        data["extractionSource"] = this.extractionSource;
        data["name"] = this.name;
        data["total"] = this.total;
        data["totalTax"] = this.totalTax;
        data["currencyCode"] = this.currencyCode;
        data["transactionTime"] = this.transactionTime ? this.transactionTime.toISOString() : <any>undefined;
        data["senderName"] = this.senderName;
        data["senderStreet"] = this.senderStreet;
        data["senderZipCode"] = this.senderZipCode;
        data["senderCity"] = this.senderCity;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["uploadedBy"] = this.uploadedBy;
        return data;
    }

    clone(): DocumentResponse {
        const json = this.toJSON();
        let result = new DocumentResponse();
        result.init(json);
        return result;
    }
}

export interface IDocumentResponse {
    id?: number;
    fileName?: string;
    fileContentType?: string;
    fileSize?: number;
    bommelId?: number;
    documentType?: DocumentType;
    privatelyPaid?: boolean;
    analysisStatus?: AnalysisStatus;
    analysisError?: string;
    extractionSource?: ExtractionSource;
    name?: string;
    total?: number;
    totalTax?: number;
    currencyCode?: string;
    transactionTime?: Date;
    senderName?: string;
    senderStreet?: string;
    senderZipCode?: string;
    senderCity?: string;
    tags?: string[];
    createdAt?: Date;
    uploadedBy?: string;

    [key: string]: any;
}

export type DocumentType = "RECEIPT" | "INVOICE";

export class DocumentUpdateRequest implements IDocumentUpdateRequest {
    name?: string;
    total?: number;
    totalTax?: number;
    currencyCode?: string;
    transactionDate?: string;
    bommelId?: number;
    senderName?: string;
    senderStreet?: string;
    senderZipCode?: string;
    senderCity?: string;
    privatelyPaid?: boolean;
    tags?: string[];

    [key: string]: any;

    constructor(data?: IDocumentUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.total = _data["total"];
            this.totalTax = _data["totalTax"];
            this.currencyCode = _data["currencyCode"];
            this.transactionDate = _data["transactionDate"];
            this.bommelId = _data["bommelId"];
            this.senderName = _data["senderName"];
            this.senderStreet = _data["senderStreet"];
            this.senderZipCode = _data["senderZipCode"];
            this.senderCity = _data["senderCity"];
            this.privatelyPaid = _data["privatelyPaid"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): DocumentUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["total"] = this.total;
        data["totalTax"] = this.totalTax;
        data["currencyCode"] = this.currencyCode;
        data["transactionDate"] = this.transactionDate;
        data["bommelId"] = this.bommelId;
        data["senderName"] = this.senderName;
        data["senderStreet"] = this.senderStreet;
        data["senderZipCode"] = this.senderZipCode;
        data["senderCity"] = this.senderCity;
        data["privatelyPaid"] = this.privatelyPaid;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }

    clone(): DocumentUpdateRequest {
        const json = this.toJSON();
        let result = new DocumentUpdateRequest();
        result.init(json);
        return result;
    }
}

export interface IDocumentUpdateRequest {
    name?: string;
    total?: number;
    totalTax?: number;
    currencyCode?: string;
    transactionDate?: string;
    bommelId?: number;
    senderName?: string;
    senderStreet?: string;
    senderZipCode?: string;
    senderCity?: string;
    privatelyPaid?: boolean;
    tags?: string[];

    [key: string]: any;
}

export type ExtractionSource = "ZUGFERD" | "AI" | "MANUAL";

/** An example of a Hopps Member */
export class Member implements IMember {
    id?: number;
    /** First Name of the Member */
    firstName!: string;
    /** Last Name of the Member */
    lastName!: string;
    email!: string;
    organizations?: Organization[];

    [key: string]: any;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(Organization.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): Member {
        const json = this.toJSON();
        let result = new Member();
        result.init(json);
        return result;
    }
}

/** An example of a Hopps Member */
export interface IMember {
    id?: number;
    /** First Name of the Member */
    firstName: string;
    /** Last Name of the Member */
    lastName: string;
    email: string;
    organizations?: Organization[];

    [key: string]: any;
}

export class NewOrganizationInput implements INewOrganizationInput {
    owner!: OwnerInput;
    newPassword!: string;
    organization!: OrganizationInput;

    [key: string]: any;

    constructor(data?: INewOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.owner = new OwnerInput();
            this.organization = new OrganizationInput();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.owner = _data["owner"] ? OwnerInput.fromJS(_data["owner"]) : new OwnerInput();
            this.newPassword = _data["newPassword"];
            this.organization = _data["organization"] ? OrganizationInput.fromJS(_data["organization"]) : new OrganizationInput();
        }
    }

    static fromJS(data: any): NewOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["newPassword"] = this.newPassword;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data;
    }

    clone(): NewOrganizationInput {
        const json = this.toJSON();
        let result = new NewOrganizationInput();
        result.init(json);
        return result;
    }
}

export interface INewOrganizationInput {
    owner: OwnerInput;
    newPassword: string;
    organization: OrganizationInput;

    [key: string]: any;
}

/** An example of a Hopps Organization, i.e. Verein */
export class Organization implements IOrganization {
    id?: number;
    name!: string;
    slug!: string;
    type!: TYPE;
    address?: Address;
    rootBommel?: Bommel;
    members?: Member[];
    website?: string;
    profilePicture?: string;

    [key: string]: any;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.rootBommel = _data["rootBommel"] ? Bommel.fromJS(_data["rootBommel"]) : <any>undefined;
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(Member.fromJS(item));
            }
            this.website = _data["website"];
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["rootBommel"] = this.rootBommel ? this.rootBommel.toJSON() : <any>undefined;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item ? item.toJSON() : <any>undefined);
        }
        data["website"] = this.website;
        data["profilePicture"] = this.profilePicture;
        return data;
    }

    clone(): Organization {
        const json = this.toJSON();
        let result = new Organization();
        result.init(json);
        return result;
    }
}

/** An example of a Hopps Organization, i.e. Verein */
export interface IOrganization {
    id?: number;
    name: string;
    slug: string;
    type: TYPE;
    address?: Address;
    rootBommel?: Bommel;
    members?: Member[];
    website?: string;
    profilePicture?: string;

    [key: string]: any;
}

export class OrganizationInput implements IOrganizationInput {
    name?: string;
    slug?: string;
    type?: TYPE;
    website?: string;
    profilePicture?: string;
    address?: Address;

    [key: string]: any;

    constructor(data?: IOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.type = _data["type"];
            this.website = _data["website"];
            this.profilePicture = _data["profilePicture"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["type"] = this.type;
        data["website"] = this.website;
        data["profilePicture"] = this.profilePicture;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): OrganizationInput {
        const json = this.toJSON();
        let result = new OrganizationInput();
        result.init(json);
        return result;
    }
}

export interface IOrganizationInput {
    name?: string;
    slug?: string;
    type?: TYPE;
    website?: string;
    profilePicture?: string;
    address?: Address;

    [key: string]: any;
}

export class OwnerInput implements IOwnerInput {
    email?: string;
    firstName?: string;
    lastName?: string;

    [key: string]: any;

    constructor(data?: IOwnerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): OwnerInput {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }

    clone(): OwnerInput {
        const json = this.toJSON();
        let result = new OwnerInput();
        result.init(json);
        return result;
    }
}

export interface IOwnerInput {
    email?: string;
    firstName?: string;
    lastName?: string;

    [key: string]: any;
}

export type TYPE = "EINGETRAGENER_VEREIN";

export class TradeParty implements ITradeParty {
    id?: number;
    name?: string;
    country?: string;
    state?: string;
    city?: string;
    zipCode?: string;
    street?: string;
    additionalAddress?: string;
    taxID?: string;
    vatID?: string;
    description?: string;

    [key: string]: any;

    constructor(data?: ITradeParty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.street = _data["street"];
            this.additionalAddress = _data["additionalAddress"];
            this.taxID = _data["taxID"];
            this.vatID = _data["vatID"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TradeParty {
        data = typeof data === 'object' ? data : {};
        let result = new TradeParty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["street"] = this.street;
        data["additionalAddress"] = this.additionalAddress;
        data["taxID"] = this.taxID;
        data["vatID"] = this.vatID;
        data["description"] = this.description;
        return data;
    }

    clone(): TradeParty {
        const json = this.toJSON();
        let result = new TradeParty();
        result.init(json);
        return result;
    }
}

export interface ITradeParty {
    id?: number;
    name?: string;
    country?: string;
    state?: string;
    city?: string;
    zipCode?: string;
    street?: string;
    additionalAddress?: string;
    taxID?: string;
    vatID?: string;
    description?: string;

    [key: string]: any;
}

export class TransactionRecord implements ITransactionRecord {
    id?: number;
    bommelId?: number;
    documentKey?: string;
    uploader?: string;
    total?: number;
    privatelyPaid?: boolean;
    document?: DocumentType;
    transactionTime?: Date;
    sender?: TradeParty;
    recipient?: TradeParty;
    tags?: string[];
    name?: string;
    orderNumber?: string;
    invoiceId?: string;
    dueDate?: Date;
    amountDue?: number;
    currencyCode?: string;

    [key: string]: any;

    constructor(data?: ITransactionRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.bommelId = _data["bommelId"];
            this.documentKey = _data["documentKey"];
            this.uploader = _data["uploader"];
            this.total = _data["total"];
            this.privatelyPaid = _data["privatelyPaid"];
            this.document = _data["document"];
            this.transactionTime = _data["transactionTime"] ? new Date(_data["transactionTime"].toString()) : <any>undefined;
            this.sender = _data["sender"] ? TradeParty.fromJS(_data["sender"]) : <any>undefined;
            this.recipient = _data["recipient"] ? TradeParty.fromJS(_data["recipient"]) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
            this.invoiceId = _data["invoiceId"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.amountDue = _data["amountDue"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): TransactionRecord {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["bommelId"] = this.bommelId;
        data["documentKey"] = this.documentKey;
        data["uploader"] = this.uploader;
        data["total"] = this.total;
        data["privatelyPaid"] = this.privatelyPaid;
        data["document"] = this.document;
        data["transactionTime"] = this.transactionTime ? this.transactionTime.toISOString() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        data["invoiceId"] = this.invoiceId;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["amountDue"] = this.amountDue;
        data["currencyCode"] = this.currencyCode;
        return data;
    }

    clone(): TransactionRecord {
        const json = this.toJSON();
        let result = new TransactionRecord();
        result.init(json);
        return result;
    }
}

export interface ITransactionRecord {
    id?: number;
    bommelId?: number;
    documentKey?: string;
    uploader?: string;
    total?: number;
    privatelyPaid?: boolean;
    document?: DocumentType;
    transactionTime?: Date;
    sender?: TradeParty;
    recipient?: TradeParty;
    tags?: string[];
    name?: string;
    orderNumber?: string;
    invoiceId?: string;
    dueDate?: Date;
    amountDue?: number;
    currencyCode?: string;

    [key: string]: any;
}

export class TreeSearchBommel implements ITreeSearchBommel {
    bommel?: Bommel;
    cyclePath?: number[];

    [key: string]: any;

    constructor(data?: ITreeSearchBommel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.bommel = _data["bommel"] ? Bommel.fromJS(_data["bommel"]) : <any>undefined;
            if (Array.isArray(_data["cyclePath"])) {
                this.cyclePath = [] as any;
                for (let item of _data["cyclePath"])
                    this.cyclePath!.push(item);
            }
        }
    }

    static fromJS(data: any): TreeSearchBommel {
        data = typeof data === 'object' ? data : {};
        let result = new TreeSearchBommel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["bommel"] = this.bommel ? this.bommel.toJSON() : <any>undefined;
        if (Array.isArray(this.cyclePath)) {
            data["cyclePath"] = [];
            for (let item of this.cyclePath)
                data["cyclePath"].push(item);
        }
        return data;
    }

    clone(): TreeSearchBommel {
        const json = this.toJSON();
        let result = new TreeSearchBommel();
        result.init(json);
        return result;
    }
}

export interface ITreeSearchBommel {
    bommel?: Bommel;
    cyclePath?: number[];

    [key: string]: any;
}

export class ValidationResult implements IValidationResult {
    violations?: Violation[];

    [key: string]: any;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["violations"])) {
                this.violations = [] as any;
                for (let item of _data["violations"])
                    this.violations!.push(Violation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.violations)) {
            data["violations"] = [];
            for (let item of this.violations)
                data["violations"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }

    clone(): ValidationResult {
        const json = this.toJSON();
        let result = new ValidationResult();
        result.init(json);
        return result;
    }
}

export interface IValidationResult {
    violations?: Violation[];

    [key: string]: any;
}

export class Violation implements IViolation {
    propertyPath?: string;
    message?: string;

    [key: string]: any;

    constructor(data?: IViolation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.propertyPath = _data["propertyPath"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Violation {
        data = typeof data === 'object' ? data : {};
        let result = new Violation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["propertyPath"] = this.propertyPath;
        data["message"] = this.message;
        return data;
    }

    clone(): Violation {
        const json = this.toJSON();
        let result = new Violation();
        result.init(json);
        return result;
    }
}

export interface IViolation {
    propertyPath?: string;
    message?: string;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}